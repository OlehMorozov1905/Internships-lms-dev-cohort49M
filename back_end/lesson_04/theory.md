# Lesson 04


**URL (Uniform Resource Locator)** — это единый указатель ресурса, используемый для идентификации и доступа к ресурсам в Интернете. Он состоит из нескольких частей, каждая из которых играет определенную роль в идентификации ресурса.

### Основные части URL

1. **Схема (Scheme)**:
    - Указывает протокол, который следует использовать для доступа к ресурсу.
    - Примеры: `http`, `https`, `ftp`, `mailto`.
    - Пример: `https`

2. **Имя пользователя и пароль (User Info)** (необязательно):
    - Указывает имя пользователя и пароль для доступа к ресурсу.
    - Формат: `username:password`
    - Пример: `user:pass`

3. **Хост (Host)**:
    - Указывает доменное имя или IP-адрес сервера, на котором находится ресурс.
    - Пример: `www.example.com`

4. **Порт (Port)** (необязательно):
    - Указывает номер порта на сервере, который следует использовать для соединения.
    - Пример: `8080`

5. **Путь (Path)**:
    - Указывает путь к ресурсу на сервере.
    - Пример: `/docs/index.html`

6. **Параметры (Query Parameters)** (необязательно):
    - Указывает дополнительные параметры запроса в виде пар ключ-значение.
    - Формат: `key1=value1&key2=value2`
    - Пример: `?search=query&lang=en`

7. **Фрагмент (Fragment)** (необязательно):
    - Указывает внутреннюю часть ресурса (например, якорь на странице).
    - Пример: `#section2`

### Пример URL

```
https://user:pass@www.example.com:8080/docs/index.html?search=query&lang=en#section2
```
___



1. **Объекты Class**: В Java для каждого типа (класса, интерфейса, массива и т. д.) существует объект `Class`, который представляет этот тип. Объект `Class` содержит метаинформацию о классе, включая его имя, поля, методы, конструкторы и суперклассы. Этот объект создается JVM при загрузке класса и используется для хранения информации о типе в runtime.

2. **Рефлексия**: С помощью рефлексии в Java можно динамически взаимодействовать с объектами `Class`. Это позволяет программам исследовать свою структуру и даже изменять поведение во время выполнения, например, создавать новые экземпляры классов, получать и устанавливать значения полей, вызывать методы и т. д.

3. **Пример использования**:
   ```java
   // Получение объекта Class
   Class<?> clazz = String.class;

   // Создание экземпляра класса по объекту Class
   String str = (String) clazz.newInstance();
   ```

### Почему это важно

Эта концепция критически важна для понимания и использования многих продвинутых особенностей Java, таких как:

- **Динамическая загрузка классов**: JVM может загружать классы по мере необходимости во время выполнения, что позволяет системам быть гибкими и адаптируемыми к различным средам выполнения.
- **Использование во фреймворках**: Многие Java-фреймворки, такие как Spring, Hibernate и другие, активно используют рефлексию для создания объектов, инъекции зависимостей и управления конфигурацией в runtime.
- **Тестирование**: Рефлексия позволяет тестовым фреймворкам, таким как JUnit, динамически находить и вызывать тестовые методы, а также манипулировать частными полями для тестирования.

Таким образом, понимание и использование объектов `Class` и рефлексии в Java позволяет разработчикам писать более гибкие, мощные и адаптируемые программы.

___

## HTTP

Протокол HTTP (HyperText Transfer Protocol) — один из основных инструментов Интернета, особенно для веб-технологий. Он выполняет ряд важных задач, которые обеспечивают функциональность сети и взаимодействие между клиентами и серверами.

Основные цели и задачи, для которых используется HTTP:

### 1. Передача данных
HTTP используется для передачи данных между клиентом (например, веб-браузером) и сервером. Эти данные могут включать в себя веб-страницы (HTML), изображения, видео, стили (CSS), скрипты (JavaScript) и другие виды мультимедийного и текстового контента.

### 2. Стандартизация коммуникации
HTTP предоставляет стандартизированный способ для серверов и клиентов общаться друг с другом. Это включает в себя использование стандартных методов (GET, POST, PUT, DELETE и др.), заголовков и статусных кодов, что позволяет различным устройствам и программному обеспечению с легкостью взаимодействовать между собой.

### 3. Управление состоянием
Хотя HTTP сам по себе является протоколом без состояния (stateless), он предоставляет механизмы для управления состоянием сессии через cookies и другие технологии, такие как сессии на стороне сервера. Это позволяет создавать более сложные приложения, которые могут отслеживать состояние пользователя через разные страницы и сессии.

### 4. Обеспечение безопасности
С развитием HTTPS, защищенной версии HTTP, обеспечивается шифрование данных между клиентом и сервером. Это критически важно для обеспечения конфиденциальности и безопасности данных пользователя, особенно при передаче чувствительной информации, такой как пароли, финансовая информация и личные данные.

### 5. Взаимодействие приложений
HTTP используется не только веб-браузерами, но и для взаимодействия между различными веб-сервисами и API. Многие современные веб-сервисы предоставляют API, работающие по HTTP, что позволяет программам легко обмениваться данными и интегрироваться друг с другом.

### 6. Масштабируемость
HTTP поддерживает масштабируемость сетевых взаимодействий, позволяя легко добавлять больше серверов или распределять нагрузку между ними. Это делает HTTP идеальным выбором для глобального веба, где сервера и клиенты могут находиться в разных частях мира.

### 7. Кэширование
HTTP поддерживает кэширование ответов, что значительно ускоряет загрузку веб-страниц и снижает нагрузку на сервера. Сервера могут указывать, какие данные могут быть закэшированы и на какое время, что позволяет браузерам и прокси-серверам сокращать время доступа к часто запрашиваемым ресурсам.

HTTP остаётся фундаментальным протоколом для функционирования веба, обеспечивая не только передачу данных, но и широкий спектр дополнительных функций, которые делают современный интернет удобным, безопасным и масштабируемым.

## TCP/IP

Протокол HTTP работает поверх протокола TCP/IP, который предоставляет базовые сетевые функции, необходимые для обмена данными между клиентом и сервером в интернете.

### Как HTTP использует TCP/IP

- **TCP (Transmission Control Protocol)**: HTTP использует TCP для установления надежного соединения между клиентом и сервером. TCP обеспечивает контроль за передачей данных, гарантируя, что все отправленные пакеты данных будут получены в том порядке, в котором они были отправлены, и без ошибок. Это делает TCP идеальным для задач, требующих надежности и целостности данных, таких как загрузка веб-страниц.

- **IP (Internet Protocol)**: IP обрабатывает адресацию и маршрутизацию в сети, позволяя данным найти путь от источника к назначению, который может находиться в любой точке мира. IP адреса используются для идентификации отправителей и получателей данных.

### Процесс взаимодействия HTTP и TCP/IP

Когда веб-браузер (клиент) делает запрос к серверу, процесс выглядит следующим образом:

- **Установление соединения**: HTTP инициирует установление TCP соединения между клиентом и сервером. Это делается с помощью процесса "рукопожатия" (handshake), который синхронизирует и подтверждает готовность обеих сторон к обмену данными.

- **Отправка HTTP запроса**: После установления TCP соединения HTTP-запросы отправляются через это соединение. Запрос включает в себя метод запроса, URL, версию протокола, заголовки и, возможно, тело запроса.

- **Передача данных**: TCP разбивает данные HTTP-запроса на пакеты, управляет их отправкой и контролирует, чтобы все пакеты были корректно доставлены и собраны в правильном порядке на стороне сервера.

- **Обработка и ответ**: Сервер обрабатывает запрос и отправляет ответ обратно клиенту через установленное TCP соединение. Ответ также разбивается на пакеты и контролируется TCP.

- **Закрытие соединения**: После завершения обмена данными соединение TCP может быть закрыто, или, в случае использования HTTP/1.1 и новее, может оставаться открытым для возможности отправки последующих запросов без необходимости нового "рукопожатия".

Этот слой связи между HTTP и TCP/IP обеспечивает эффективное и надежное взаимодействие в Интернете, позволяя пользователям и серверам обмениваться данными с высокой степенью уверенности в их доставке и целостности.

### Ключевые особенности HTTP:

1. **Работает поверх TCP/TLS**: Использует TCP для надежной передачи данных, а TLS (Transport Layer Security) для шифрования, обеспечивая безопасность данных в процессе передачи.

2. **Протокл "запрос-ответ"**: Клиент отправляет запрос на сервер, а сервер возвращает ответ. Эта модель прямого обмена сообщениями делает структуру взаимодействия простой и понятной.

3. **Без сохранения состояния (Stateless)**: HTTP сам по себе не сохраняет никаких данных между двумя запросами. Это означает, что каждый запрос независим, и сервер не сохраняет информацию о состоянии клиента между запросами. Тем не менее, для управления состоянием сессии обычно используются cookies. Это позволяет серверу отслеживать состояние пользователя без необходимости сохранения информации на сервере.

4. **Текстовый протокол**: HTTP использует читаемые человеком текстовые форматы для формирования запросов и ответов, что облегчает отладку и тестирование, но может увеличить объем передаваемых данных.

5. **Расширяемый протокол**: HTTP позволяет добавлять новые функции без нарушения существующих операций. Это достигается за счет использования заголовков, кодов состояния и методов, которые могут быть расширены или настроены для поддержки новых возможностей.

## Структура запроса:

В запросе, отправляемом по протоколу HTTP, передаются различные данные и метаинформация, которые помогают серверу корректно обработать запрос и вернуть соответствующий ответ.

Основные компоненты HTTP-запроса:

### 1. **Стартовая строка (Start Line)**
- **Метод запроса**: Один из HTTP методов, таких как GET, POST, PUT, DELETE и т.д., указывающий на тип операции, которую клиент хочет выполнить.
- **URL (или URI)**: Адрес ресурса, к которому осуществляется доступ. **Host отдельно!**
- **Версия протокола HTTP**: Обычно это HTTP/1.1 или HTTP/2.

### 2. **Заголовки (Headers)**
Заголовки запроса содержат метаинформацию о запросе и клиенте:
- **Host**: Адрес сервера.
- **User-Agent**: Информация о клиентском приложении, браузере или другом агенте, который отправил запрос.
- **Accept**: Типы контента, которые клиент готов принять от сервера.
- **Content-Type**: Тип данных, отправляемых в теле запроса (например, `application/json`).
- **Authorization**: Информация для аутентификации и авторизации (например, токены доступа).
- **Cookie**: Куки, которые были установлены сервером в предыдущих ответах и содержат состояние сессии или другие данные.
- **Connection**: Управление соединением, например, `keep-alive` для постоянного соединения.
- **Cache-Control**: Директивы для управления кэшированием как на клиенте, так и на сервере.

### 3. **Тело запроса (Body) (не всегда)**
Тело запроса присутствует, если метод запроса подразумевает отправку данных (например, POST или PUT). В теле могут передаваться данные форм, файлы, JSON-объекты и другие типы данных, в зависимости от типа запроса и его цели.

### 4. **Пустая строка**
Отделяет заголовки HTTP-запроса от тела запроса, если тело присутствует.

### Пример HTTP-запроса:

```
POST /api/data HTTP/1.1
Host: www.example.com
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36
Accept: application/json
Content-Type: application/json
Authorization: Bearer access_token_here
Cookie: sessionId=abc123; username=user
Connection: keep-alive
Cache-Control: no-cache

{
  "name": "John",
  "age": 30
}
```

В этом запросе клиент отправляет данные в формате JSON на сервер с использованием метода POST. Запрос включает заголовки для определения типа контента, метода аутентификации, информации о клиенте и управления соединением.

## Методы HTTP

HTTP определяет методы, которые указывают действие, которое должно быть выполнено для заданного ресурса.

Наиболее часто используемые методы:
- **GET** — запрос на получение данных.
- **POST** — отправка данных на сервер для создания или обновления ресурса.
- **PUT** — замена текущего представления ресурса данными запроса.
- **DELETE** — удаление указанного ресурса.
- **HEAD** — аналогичен GET, но в ответ возвращается только заголовки без тела.
- **OPTIONS** — описание коммуникационных параметров для ресурса.

## Коды ответов

**Статусные коды**: Сервер ответит на запрос одним из стандартных HTTP статусных кодов.

HTTP статусные коды классифицируются на пять основных категорий, каждая из которых имеет свой собственный диапазон значений и указывает на определенный тип ответа сервера.

### 1xx: Информационные

Статусные коды из этой категории сообщают клиенту о процессе обработки его запроса. Они используются редко и представляют временные ответы, которые указывают на то, что запрос был получен и клиент может продолжать отправку дополнительных запросов или игнорировать ответ, если запрос уже выполнен.

- **100 Continue**: Клиент должен продолжать отправку запроса.
- **101 Switching Protocols**: Клиент просил сервер переключить протоколы и сервер согласился.

### 2xx: Успешные

Эта категория указывает на то, что запрос был успешно получен, понят, и обработан. Они обозначают успешное выполнение запроса.

- **200 OK**: Стандартный ответ для успешных HTTP-запросов.
- **201 Created**: Запрос был выполнен и в результате был создан новый ресурс.
- **204 No Content**: Запрос был успешно обработан, но в ответе не передается тело сообщения.

### 3xx: Перенаправления

Коды в этой категории сообщают, что для завершения запроса клиенту нужно выполнить дополнительные действия, обычно связанные с перенаправлением на другой URI.

- **301 Moved Permanently**: Ресурс окончательно перемещен на новый URI, указанный в заголовке Location.
- **302 Found**: Ресурс временно перемещен на другой URI.
- **304 Not Modified**: Ресурс не был изменен с момента последнего запроса клиента (используется для кэширования).

### 4xx: Ошибки клиента

Ответы из этой категории указывают на ошибки со стороны клиента, например, неправильно сформированный запрос или запрос к несуществующему ресурсу.

- **400 Bad Request**: Сервер не может обработать запрос из-за ошибки в клиентском запросе.
- **401 Unauthorized**: Для доступа к ресурсу требуется аутентификация.
- **403 Forbidden**: Сервер понял запрос, но отказывает в доступе.
- **404 Not Found**: Запрашиваемый ресурс не найден на сервере.
- **429 Too Many Requests**: Клиент отправил слишком много запросов за короткий промежуток времени.

### 5xx: Ошибки сервера

Коды в этой категории указывают на ошибки на стороне сервера, которые препятствуют выполнению валидного запроса.

- **500 Internal Server Error**: Неопределенная ошибка сервера, которая не позволяет выполнить запрос.
- **501 Not Implemented**: Сервер не поддерживает функциональность, необходимую для выполнения запроса.
- **503 Service Unavailable**: Сервер временно не доступен, обычно из-за перегрузки или технического обслуживания.

Каждый из этих статусных кодов имеет свою роль в диагностике взаимодействий между клиентом и сервером, помогая разработчикам понять, что произошло при обработке запроса.

[статья HTTP](https://developer.mozilla.org/ru/docs/Web/HTTP)

___

### JAR-архив

**JAR** (Java ARchive) — это формат архивного файла, используемый для агрегации множества файлов Java-приложения (байт-код, классы, ассоциированные ресурсы и мета-информация) в один файл. Эти файлы обычно содержат все данные, необходимые для исполнения или распределения приложения Java. JAR-файлы основаны на стандартном формате ZIP, но имеют расширение `.jar`.

### Сборка проекта

**Сборка** — это процесс, в котором исходный код приложения компилируется в исполняемый формат, тестируется, упаковывается и готовится к развертыванию. В контексте Java это обычно включает компиляцию исходных файлов `.java` в байт-код `.class`, упаковку этих файлов в JAR-архивы или другие типы дистрибутивов, а также выполнение различных других задач, таких как генерация документации и запуск автоматизированных тестов.

## Maven

Maven — это инструмент автоматизации сборки, разработанный Apache Software Foundation.
Он используется в основном для проектов Java, но также подходит для проектов на других языках программирования, таких как C#, Ruby, Scala и другие.

<a href="https://maven.apache.org/" target="_blank">Maven site</a>

<a href="https://mvnrepository.com/" target="_blank">MVN Repository</a>


`Maven` — это инструмент для управления проектами и зависимостями.

Основная цель Maven — предоставить способ, который облегчает процесс сборки (build) проекта. Он помогает в управлении:
- Зависимостями (библиотеками, которые требуются проекту)
- Сборкой проекта
- Документацией
- Отчётами
- Распределением
- Сотрудничеством

### Ключевые особенности Maven

1. **Централизованное управление зависимостями**: Maven автоматически скачивает библиотеки и плагины, указанные в файле конфигурации (обычно это `pom.xml`), и управляет их версиями.
2. **Модель проекта на основе соглашения**: Maven использует стандартную структуру каталогов и соглашения по именованию, сокращая количество конфигурационных настроек, которые необходимо указывать.
3. **Плагины**: Maven расширяем за счёт плагинов, которые могут выполнять различные задачи, такие как компиляция кода, упаковка и деплой.

####  Структура проекта

Стандартная структура каталогов Maven выглядит следующим образом:
- `src/main/java`: исходный код
- `src/main/resources`: ресурсы, которые должны быть включены в итоговый пакет
- `src/test/java`: исходный код тестов
- `src/test/resources`: ресурсы, используемые при тестировании
- `target`: каталог, в который Maven помещает скомпилированные файлы и итоговый пакет

####  Работа с POM.xml

`pom.xml` — это основной файл конфигурации Maven. Он содержит информацию о проекте и конфигурацию сборки. Пример простого `pom.xml`:

```xml
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>my-application</artifactId>
    <version>1.0</version>
</project>
```

Maven — мощный инструмент для управления проектами, который помогает разработчикам сосредоточиться на кодировании, минимизируя рутинные задачи по управлению зависимостями и сборке проекта.

### Жизненный цикл сборки в Maven

Maven управляет процессом сборки через так называемый **жизненный цикл сборки**, который состоит из различных фаз. Основные жизненные циклы Maven включают:

1. **default** (основной жизненный цикл): управляет развертыванием приложения.
2. **clean**: очищает проект, удаляя все файлы, созданные предыдущими сборками.
3. **site**: создает документацию проекта, такую как отчеты, статистику и т.д.

### Фазы жизненного цикла сборки

Каждый жизненный цикл состоит из последовательности фаз. Например, жизненный цикл **default** включает следующие ключевые фазы:
- **validate** — проверка корректности проекта.
- **compile** — компиляция исходного кода проекта.
- **test** — тестирование скомпилированного кода с использованием подходящей тестовой среды.
- **package** — упаковка скомпилированного кода в JAR-архив или другой дистрибутив.
- **verify** — проверка пакета на соответствие критериям качества.
- **install** — установка пакета в локальный репозиторий Maven, что делает его доступным для использования в других проектах на этой машине.
- **deploy** — стабильная версия пакета распространяется на удаленный репозиторий для совместного использования с другими разработчиками и проектами.

### Плагины Maven

**Плагины** в Maven — это компоненты, которые выполняют конкретные задачи в рамках фазы жизненного цикла. Например, плагин `maven-compiler-plugin` отвечает за компиляцию исходного кода, `maven-surefire-plugin` управляет запуском тестов, а `maven-jar-plugin` упаковывает скомпилированный код в JAR-файлы.

Каждый плагин может быть настроен в файле `pom.xml` для выполнения его задач в определенные моменты жизненного цикла сборки. Это позволяет разработчикам настраивать процесс сборки в соответствии с потребностями проекта, обеспечивая гибкость и мощные возможности автоматизации.

___

## Jackson

<a href="https://github.com/FasterXML/jackson-docs" target="_blank">Джексон (библиотека Java JSON)</a>

`Jackson` - это библиотека для работы с форматом данных [JSON](https://www.json.org/json-en.html){:target="_blank"} в языке Java.
Она предоставляет удобные средства для чтения (deserialization) и записи (serialization) объектов Java в формат JSON и обратно.

Основные возможности библиотеки Jackson включают в себя:

1. **Простота использования**: Jackson предоставляет простые API для преобразования объектов Java в JSON и наоборот, что делает работу с JSON в Java приложениях легкой и удобной.

2. **Высокая производительность**: Jackson обладает высокой скоростью работы благодаря оптимизации алгоритмов парсинга и сериализации JSON.

3. **Поддержка различных форматов**: Jackson поддерживает различные форматы JSON, такие как JSON Object, JSON Array, и др., а также различные методы сериализации и десериализации, включая JSON binding и JSON streaming.

4. **Гибкость конфигурации**: Библиотека предоставляет множество настраиваемых параметров и аннотаций для тонкой настройки процесса преобразования объектов.

Jackson широко используется в Java-приложениях для работы с данными в формате JSON, таких как веб-сервисы, RESTful API, клиент-серверные приложения и другие. Она является одной из наиболее популярных и широко используемых библиотек для работы с JSON в Java.

### Почему именно Jackson?

В рамках `Spring Framework` библиотека Jackson интегрирована и настроена для работы с JSON данными по умолчанию.
Spring MVC и Spring Boot автоматически используют Jackson для сериализации и десериализации объектов Java в JSON и наоборот при обработке HTTP-запросов и ответов.

Spring Framework предоставляет поддержку аннотаций Jackson для тонкой настройки процесса сериализации и десериализации.

Например, аннотация `@JsonProperty` позволяет указать имя поля или метода в JSON объекте, `@JsonFormat` используется для форматирования дат и времени в JSON, `@JsonIgnore` исключает определенные поля из сериализации и десериализации, и т.д.

Благодаря этой интеграции, разработчики могут легко работать с JSON данными в своих Spring приложениях без необходимости вручную настраивать процесс сериализации и десериализации.

___

### Сервлет

Сервлет — это Java-программа, которая работает на сервере и обрабатывает запросы клиента в рамках протокола HTTP. 
Сервлеты являются компонентом Java EE (Enterprise Edition) и предназначены для расширения возможностей серверов, обрабатывающих запросы клиентов, такие как веб-серверы.

Сервлет в Java — это технология, используемая для создания веб-приложений. 
Она обеспечивает платформу для разработки серверных программ на Java, которые могут общаться с клиентами по протоколу HTTP (или другим протоколам), обрабатывая запросы и отправляя ответы.

Сервлеты выполняют следующие основные функции:

1. **Чтение данных клиента**, отправленных через HTTP. Данные могут быть отправлены различными способами, включая GET и POST.
2. **Обработка этих данных**: сервлет может обрабатывать входные данные и выполнять различные операции, такие как доступ к базе данных, вызов внешних сервисов и другие вычислительные задачи.
3. **Генерация ответов**: после обработки данных сервлет генерирует ответ в формате, который может воспринимать клиент (обычно это HTML, но также может быть данные JSON, XML и другие).
4. **Отправка данных обратно клиенту** через HTTP.

Сервлеты работают в пределах сервлет-контейнера (также называемого сервером приложений), который обрабатывает множество низкоуровневых деталей, включая управление жизненным циклом сервлета, масштабирование, безопасность, управление сессиями и многое другое.

Классическим примером сервера приложений, поддерживающего сервлеты, является Apache Tomcat, который представляет собой один из самых популярных сервлет-контейнеров.


### Java Servlet API

Java Servlet API представляет собой стандартизированный набор интерфейсов и классов, который делает возможной разработку таких веб-приложений. 
Сервлеты работают на сервере и могут обрабатывать клиентские запросы следующим образом:

1. **Получение запроса**: Клиент (обычно веб-браузер) отправляет запрос на сервер, где размещается сервлет. Этот запрос может быть вызван различными событиями, например, пользователь может заполнить форму на веб-странице и нажать кнопку отправки.

2. **Обработка запроса**: Сервлет анализирует полученный запрос, выполняет необходимую обработку данных или бизнес-логику, и подготавливает ответ. Это может включать в себя выполнение операций с базой данных, интеграцию с другими веб-сервисами и так далее.

3. **Отправка ответа**: После обработки запроса сервлет генерирует ответ, который может быть в форме HTML, JSON, XML и других форматов, и отправляет его обратно клиенту.

Сервлеты обеспечивают высокую производительность и масштабируемость, поскольку они поддерживают многопоточную обработку запросов, что делает их идеальными для современных интерактивных веб-приложений.


Dispatcher Servlet в Spring Framework — это сервлет, который распределяет запросы на различные контроллеры. Он играет центральную роль в обработке всех HTTP-запросов, которые проходят через приложение, созданное с использованием Spring.

Когда веб-приложение на Spring получает HTTP-запрос, Dispatcher Servlet определяет, к какому контроллеру следует направить этот запрос. Он основывает свое решение на конфигурации, которая может быть задана аннотациями в коде или в XML-файлах конфигурации.

После того как Dispatcher Servlet определяет соответствующий контроллер, он перенаправляет запрос к этому контроллеру. Контроллер затем обрабатывает запрос, взаимодействует с необходимыми моделями (например, для получения или обновления данных) и возвращает модель и представление, которые должны быть отображены. Dispatcher Servlet затем перенаправляет этот ответ обратно пользователю, обычно в виде HTML-страницы.

Таким образом, Dispatcher Servlet упрощает маршрутизацию в приложениях Spring, обеспечивая централизованное место для управления всеми входящими HTTP-запросами.



+ Статья об HTTP в Википедии - https://ru.wikipedia.org/wiki/HTTP

+ Что такое URI, URL и URN - https://habr.com/ru/articles/190154/



+ Основные HTTP методы:

    1. GET - используется для запроса данных с определенного ресурса,
       на котором данные не изменяются, поскольку GET-запросы не изменяют состояние ресурса.
    2. PUT - метод для обновления существующего на сервере ресурса,
       при этом используется содержимое тела запроса.
    3. POST - используется для отправки данных на сервер для создания ресурса.
    4. DELETE - удаляет определённый ресурс.



+ Servlet — это Java компонент, который управляется контейнером и генерирует динамическое содержимое. Как и другие Java компоненты, сервлет является Java классом, который скомпилирован в байт-код и может быть загружен на веб-сервер, использующий технологию Java.

+ Контейнер сервлетов — это некоторая часть веб-сервера или сервера приложений, предоставляющая сетевые сервисы, через которые отправляются запросы и ответы.

+ Для того чтобы приложение могло работать на веб-сервере, оно упаковывается в WAR файл.

+ WAR (Web ARchive) файл - разновидность архива, имеющая определённую структуру файлов и папок и содержащая все файлы, необходимые для работы приложения



### Tomcat

Tomcat (в старых версиях — Catalina) — контейнер сервлетов с открытым исходным кодом,
разрабатываемый Apache Software Foundation. Реализует спецификацию сервлетов,
спецификацию JavaServer Pages (JSP) и JavaServer Faces (JSF). Написан на языке Java.

Tomcat позволяет запускать веб-приложения и содержит ряд программ для самоконфигурирования.

Скачать Tomcat можно с официального сайта разработчика - https://tomcat.apache.org/download-10.cgi

___

Если Tomcat не запускается, нужно добавить системную переменную среды:
Имя: JAVA_HOME
Значение: путь к установленной JDK, например C:\Program Files\Java\jdk-17.0.3
Добавлять переменную в НИЖНЕЕ окно (Системные переменные)

Инструкция - https://remontka.pro/environment-variables-windows/

___

Для тестирования веб-приложений удобно использовать Postman.
Скачать можно по ссылке - https://www.postman.com/downloads/

